#n Wyam.Yaml
#n Wyam.Razor
#n Wyam.Markdown
#n Wyam.Json
#n Wyam.Sass
#n Wyam.Minification
#n Wyam.Feeds

#n Octokit -v 0.29.0
#n AngleSharp -v 0.9.9.1
#n Microsoft.SyndicationFeed.ReaderWriter -v 1.0.2

using System.Collections.Concurrent;
using System.Threading.Tasks;
using System.Net;
using System.Net.Http;
using System.Xml;
using System.IO;
using Octokit;
using AngleSharp;
using Microsoft.SyndicationFeed;
using Microsoft.SyndicationFeed.Rss;
using Microsoft.SyndicationFeed.Atom;
using Newtonsoft.Json;

Settings[Keys.Host] = "discoverdot.net";
Settings[Keys.LinksUseHttps] = true;

//////////////////////////////////////////////////////////////////////
// Pipelines
//////////////////////////////////////////////////////////////////////

// Projects and Issues
//////////////////////////////////////////////////////////////////////

Pipelines.Add("Projects",
    ReadFiles("data/projects/*.yml"),    
    If(ctx => ctx.Bool("Preview"),
        OrderBy((doc, ctx2) => doc.Source),        
        Take(10)),
    Yaml(),    
    Content(string.Empty),
    Execute((inputs, ctx, _) => GetProjectGitHubData(inputs, ctx).Result),
    Execute((inputs, ctx, _) => GetProjectNuGetData(inputs, ctx).Result),
    Meta("Key", (doc, ctx) => doc.Source.FileNameWithoutExtension.FullPath),
    Meta(Keys.RelativeFilePath, (doc, ctx) => "projects/" + doc.Source.FileName.ChangeExtension(".html")),
    Razor()
        .WithLayout("/projects/_Layout.cshtml"),
    WriteFiles(),
    Meta("Link", (doc, ctx) => ctx.GetLink(doc)),
    Meta("DonationsData", (doc, ctx) => doc.GetMetadata(
        "Website",
        "NuGet",
        "Source",
        "Donations"
    )),
    Meta("SearchData", (doc, ctx) => doc.GetMetadata(
        "Key",
        "Title",
        "Description",
        "StargazersCount",
        "Tags"
    )),
    Meta("CardData", (doc, ctx) => doc.GetMetadata(
        "Key",
        "Title",
        "Link",
        "Image",
        "NuGet",
        "Source",
        "Description",
        "StargazersCount",
        "ForksCount",
        "OpenIssuesCount",
        "PushedAt",
        "Website",
        "Donations",
        "Language",
        "Tags",
        "DiscoveryDate",
        "Comment",
        "Platform",
        "Microsoft",
        "Foundation"
    ))
);

Pipelines.Add("Project Data",
    GenerateJson((doc, ctx) =>
        ctx.Documents.FromPipeline("Projects").Select(x => x["CardData"]))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/projects.json")
);

Pipelines.Add("Individual Project Data",
    Documents("Projects"),
    GenerateJson((doc, ctx) => doc["CardData"])
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/projects/" + doc.Source.FileName.ChangeExtension(".json"))
);

Pipelines.Add("Project Search Data",
    GenerateJson((doc, ctx) =>
        ctx.Documents.FromPipeline("Projects").Select(x => x["SearchData"]))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/search/projects.json")
);

Pipelines.Add("Donations Data",
    GenerateJson((doc, ctx) =>
        ctx.Documents.FromPipeline("Projects")
            .Where(x => x.ContainsKey("Donations"))
            .Select(x => x.GetMetadata(
                "Title",
                "Website",
                "NuGet",
                "Source",
                "Donations"
            ))
        )
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/donations.json")
);

Pipelines.Add("Project Keys",
    GenerateJson((doc, ctx) =>
        ctx.Documents.FromPipeline("Projects")
            .Select(x => x.GetMetadata(
                "Key",
                "Title",
                "Link")))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/project-keys.json")
);

// Blogs and Posts
//////////////////////////////////////////////////////////////////////

Pipelines.Add("Blogs",
    ReadFiles("data/blogs/*.yml"),    
    If(ctx => ctx.Bool("Preview"),
        OrderBy((doc, ctx2) => doc.Source),        
        Take(5)),
    Yaml(),    
    Content(string.Empty),
    Execute((inputs, ctx, _) => GetFeedData(inputs, ctx).Result.Where(x => x != null)),
    Meta("Key", (doc, ctx) => doc.Source.FileNameWithoutExtension.FullPath),
    Meta(Keys.RelativeFilePath, (doc, ctx) => "blogs/" + doc.Source.FileName.ChangeExtension(".html")),
    Meta("Language", (doc, ctx) => doc.String("Language", "English")),
    Razor()
        .WithLayout("/blogs/_Layout.cshtml"),
    WriteFiles(),
    Meta("Link", (doc, ctx) => ctx.GetLink(doc)),
    Meta("SearchData", (doc, ctx) => doc.GetMetadata(
        "Key",
        "Title",
        "Description"
    )),
    Meta("CardData", (doc, ctx) => doc.GetMetadata(
        "Key",
        "Title",
        "Image",
        "Link",
        "Description",
        "Author",
        "Website",
        "Feed",
        "Comment",
        "Language",
        "LastPublished",
        "NewestFeedItem",
        "DiscoveryDate"
    ))
);

Pipelines.Add("Blog Data",
    GenerateJson((doc, ctx) =>
        @ctx.Documents.FromPipeline("Blogs").Select(x => x["CardData"]))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/blogs.json")
);

Pipelines.Add("Individual Blog Data",
    Documents("Blogs"),
    GenerateJson((doc, ctx) => doc["CardData"])
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/blogs/" + doc.Source.FileName.ChangeExtension(".json"))
);

Pipelines.Add("Blog Search Data",
    GenerateJson((doc, ctx) =>
        ctx.Documents.FromPipeline("Blogs").Select(x => x["SearchData"]))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/search/blogs.json")
);

Pipelines.Add("Posts",
    Documents("Blogs"),
    Where((doc, ctx) => doc.ContainsKey("FeedItems") && doc.String("Language") == "English"),
    GenerateJson((doc, ctx) => doc["FeedItems"])
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/posts/" + doc.Source.FileName.ChangeExtension(".json"))
);

Pipelines.Add("Post Search Data",
    GenerateJson((doc, ctx) => ctx.Documents.FromPipeline("Blogs")
        .Where(d => d.ContainsKey("FeedItems") && d.String("Language") == "English")
        .SelectMany(d => d.Get<IEnumerable<FeedItemData>>("FeedItems")
            .Select(i => new
            {
                Title = i.Title,
                Link = i.Link,
                Published = i.Published
            })))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/search/posts.json")
);

// Broadcasts and Episodes
//////////////////////////////////////////////////////////////////////

Pipelines.Add("Broadcasts",
    ReadFiles("data/broadcasts/*.yml"),    
    If(ctx => ctx.Bool("Preview"),
        OrderBy((doc, ctx2) => doc.Source),        
        Take(5)),
    Yaml(),    
    Content(string.Empty),
    Execute((inputs, ctx, _) => GetFeedData(inputs, ctx).Result.Where(x => x != null)),
    Meta("Key", (doc, ctx) => doc.Source.FileNameWithoutExtension.FullPath),
    Meta(Keys.RelativeFilePath, (doc, ctx) => "broadcasts/" + doc.Source.FileName.ChangeExtension(".html")),
    Meta("Language", (doc, ctx) => doc.String("Language", "English")),
    Razor()
        .WithLayout("/broadcasts/_Layout.cshtml"),
    WriteFiles(),
    Meta("Link", (doc, ctx) => ctx.GetLink(doc)),
    Meta("SearchData", (doc, ctx) => doc.GetMetadata(
        "Key",
        "Title",
        "Description"
    )),
    Meta("CardData", (doc, ctx) => doc.GetMetadata(
        "Key",
        "Title",
        "Image",
        "Link",
        "Description",
        "Author",
        "Website",
        "Feed",
        "Comment",
        "Language",
        "LastPublished",
        "NewestFeedItem",
        "DiscoveryDate"
    ))
);

Pipelines.Add("Broadcast Data",
    GenerateJson((doc, ctx) =>
        @ctx.Documents.FromPipeline("Broadcasts").Select(x => x["CardData"]))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/broadcasts.json")
);

Pipelines.Add("Individual Broadcast Data",
    Documents("Broadcasts"),
    GenerateJson((doc, ctx) => doc["CardData"])
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/broadcasts/" + doc.Source.FileName.ChangeExtension(".json"))
);

Pipelines.Add("Broadcast Search Data",
    GenerateJson((doc, ctx) =>
        ctx.Documents.FromPipeline("Broadcasts").Select(x => x["SearchData"]))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/search/broadcasts.json")
);

Pipelines.Add("Episodes",
    Documents("Broadcasts"),
    Where((doc, ctx) => doc.ContainsKey("FeedItems") && doc.String("Language") == "English"),
    GenerateJson((doc, ctx) => doc["FeedItems"])
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/episodes/" + doc.Source.FileName.ChangeExtension(".json"))
);

Pipelines.Add("Episode Search Data",
    GenerateJson((doc, ctx) => ctx.Documents.FromPipeline("Episodes")
        .Where(d => d.ContainsKey("FeedItems") && d.String("Language") == "English")
        .SelectMany(d => d.Get<IEnumerable<FeedItemData>>("FeedItems")
            .Select(i => new
            {
                Title = i.Title,
                Link = i.Link,
                Published = i.Published
            })))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/search/episodes.json")
);

// Groups And Events
//////////////////////////////////////////////////////////////////////

Pipelines.Add("Groups",
    ReadFiles("data/groups/*.yml"),    
    If(ctx => ctx.Bool("Preview"),
        OrderBy((doc, ctx2) => doc.Source),        
        Take(10)),
    Yaml(),    
    Content(string.Empty),
    Execute((inputs, ctx, _) => GetMeetupData(inputs, ctx).Result),
    Meta("Link", (doc, ctx) => doc.String("Website")),
    Meta("CardType", "Group"),
    Meta("CardData", (doc, ctx) => doc.GetMetadata(
        "Website",
        "Title",
        "Image",
        "Location",
        "Country",
        "Lat",
        "Lon",
        "CardType",
        "Comment",
        "NextEventWebsite",
        "NextEventTitle",
        "NextEventDate",
        "NextEventTime",
        "DiscoveryDate"
    ))
);

Pipelines.Add("Group Data",
    GenerateJson((doc, ctx) =>
        @ctx.Documents.FromPipeline("Groups").Select(x => x["CardData"]))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/groups.json")
);

Pipelines.Add("Events",
    ReadFiles("data/events/*.yml"),    
    If(ctx => ctx.Bool("Preview"),
        OrderBy((doc, ctx2) => doc.Source),        
        Take(10)),
    Yaml(),
    Concat(
        Documents("Groups"),
        Where((doc, ctx) => doc.ContainsKey("NextEvent")),
        Execute((doc, ctx) => ctx.GetDocument((MetadataItems)doc["NextEvent"]))
    ),
    OrderBy((doc, ctx) => doc.String("Date")),
    Content(string.Empty),
    Meta("Link", (doc, ctx) => doc.String("Website")),
    Meta("CardType", "Event"),
    Meta("CardData", (doc, ctx) => doc.GetMetadata(
        "Website",
        "Title",
        "Description",
        "Image",
        "Location",
        "Country",
        "Lat",
        "Lon",
        "Date",
        "EndDate",
        "Time",
        "EndTime",
        "CardType",
        "Comment",
        "NextEvent",
        "DiscoveryDate"
    ))
);

Pipelines.Add("Event Data",
    GenerateJson((doc, ctx) =>
        @ctx.Documents.FromPipeline("Events").Select(x => x["CardData"]))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/events.json")
);

// Resources
//////////////////////////////////////////////////////////////////////

Pipelines.Add("Resources",
    ReadFiles("data/resources/*.yml"),    
    If(ctx => ctx.Bool("Preview"),
        OrderBy((doc, ctx2) => doc.Source),        
        Take(10)),
    Yaml(),    
    Content(string.Empty),
    Meta("Link", (doc, ctx) => doc.String("Website")),
    Meta("CardType", "Resource"),
    Meta("SearchData", (doc, ctx) => doc.GetMetadata(
        "Website",
        "Title",
        "Description",
        "Tags"
    )),
    Meta("CardData", (doc, ctx) => doc.GetMetadata(
        "Website",
        "Title",
        "Image",
        "Description",
        "CardType",
        "Comment",
        "Tags",
        "DiscoveryDate"
    ))
);

Pipelines.Add("Resource Data",
    GenerateJson((doc, ctx) =>
        @ctx.Documents.FromPipeline("Resources").Select(x => x["CardData"]))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/resources.json")
);

Pipelines.Add("Resource Search Data",
    GenerateJson((doc, ctx) =>
        ctx.Documents.FromPipeline("Resources").Select(x => x["SearchData"]))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/search/resources.json")
);

// Aggregate, Pages, and Resources
//////////////////////////////////////////////////////////////////////

Pipelines.Add("News",
    GenerateJson((doc, ctx) => ctx.Documents.FromPipeline("Posts")
        .Concat(ctx.Documents.FromPipeline("Episodes"))
        .SelectMany(d => d.Get<IEnumerable<FeedItemData>>("FeedItems")
            .Where(p => p.Recent)
            .Select(p => new
            {
                FeedLink = d.String("Link"),
                FeedTitle = d.String("Title"),
                Published = p.Published,
                Link = p.Link,
                Title = p.Title,
                Links = p.Links,
                Author = p.Author
            }))
        .OrderByDescending(x => x.Published))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/news.json")
);

Pipelines.Add("Discoveries",
    Documents("Projects"),
    Concat(
        Documents("Blogs")
    ),
    Concat(
        Documents("Broadcasts")
    ),
    Concat(
        Documents("Groups")
    ),
    Concat(
        Documents("Events")
    ),
    Concat(
        Documents("Resources")
    ),
    Where(@doc.ContainsKey("DiscoveryDate")),
    Where(@doc.DateTime("DiscoveryDate") <= DateTime.Today),
    OrderBy(@doc.DateTime("DiscoveryDate"))
        .Descending()
);

Pipelines.Add("Discovery",
    Documents("Discoveries"),
    Take(1),
    GenerateJson((doc, ctx) => doc["CardData"])
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/discovery.json")
);

Pipelines.Add("Past Discoveries",
    GenerateJson(ctx =>
        ctx.Documents.FromPipeline("Discoveries")
            .Skip(1)
            .Take(4)
            .Select(x => x["CardData"]))
        .WithCamelCase(),
    MinifyJs(),
    WriteFiles((doc, ctx) => "data/past-discoveries.json")
);

Pipelines.Add("Pages",
    ReadFiles("**/{!_,}*.md"),
    FrontMatter(Yaml()),
    Markdown()
        .UseExtensions(),
    WriteFiles(".html").OnlyMetadata(),
    Razor()
        .WithLayout("/_MarkdownLayout.cshtml"),
    Concat(
        ReadFiles("**/{!_,}*.cshtml"),
        FrontMatter(Yaml()),
        WriteFiles(".html").OnlyMetadata(),
        Razor()
            .WithLayout("/_Layout.cshtml")
    ),
    WriteFiles()
);

Pipelines.Add("Sass",
    ReadFiles("**/{!_,}*.scss"),
    Sass()
        .WithCompactOutputStyle(),
    WriteFiles()
);

Pipelines.Add("Site Resources",
    CopyFiles("**/*{!.cshtml,!.md,!.less,!.yml,!.scss,}")
);

// Feeds
//////////////////////////////////////////////////////////////////////

Pipelines.Add("News Feed",
    Documents("Posts"),
    Concat(Documents("Episodes")),
    Where((doc, ctx) => doc.Get<FeedItemData>("FeedItems").Recent),
    OrderBy((doc, ctx) => doc.Get<FeedItemData>("FeedItems").Published).Descending(),
    GenerateFeeds()
        .WithAtomPath(_ => "feeds/news.atom")
        .WithRssPath(_ => "feeds/news.rss")
        .WithFeedTitle(_ => "Recent News From Discover .NET")
        .WithFeedDescription(_ => "A roundup of recent blog posts, podcasts, and more.")
        .WithItemTitle((doc, ctx) => doc.Get<FeedItemData>("FeedItems").Title)
        .WithItemDescription((doc, ctx) => doc.Get<FeedItemData>("FeedItems").Description)
        .WithItemPublished((doc, ctx) => doc.Get<FeedItemData>("FeedItems").Published.DateTime)
        .WithItemLink((doc, ctx) => doc.Get<FeedItemData>("FeedItems").Link)
        .WithItemId((doc, ctx) => doc.Get<FeedItemData>("FeedItems").Link)
        .WithItemAuthor((doc, ctx) => 
            doc.Get<FeedItemData>("FeedItems").Author
            ?? doc.String("Author")
            ?? doc.String("Title")
        )
        .WithItemImageLink((doc, ctx) => null),
    WriteFiles()
);

Pipelines.Add("Discoveries Feed",
    Documents("Discoveries"),
    Take(10),
    GenerateFeeds()
        .WithAtomPath(_ => "feeds/discoveries.atom")
        .WithRssPath(_ => "feeds/discoveries.rss")
        .WithFeedTitle(_ => "Recent Discoveries From Discover .NET")
        .WithFeedDescription(_ => "A new discovery (almost) every day.")
        .WithItemTitle((doc, ctx) => doc.String("Title"))
        .WithItemDescription((doc, ctx) => doc.String("Description"))
        .WithItemPublished((doc, ctx) => doc.DateTime("DiscoveryDate"))
        .WithItemLink((doc, ctx) => ctx.GetLink(doc.String("Link"), true))
        .WithItemId((doc, ctx) => ctx.GetLink(doc.String("Link"), true))
        .WithItemImageLink((doc, ctx) => null),
    WriteFiles()
);

Pipelines.Add("OPML Feed", 
    ReadFiles("_feeds.cshtml"),
    Razor().IgnorePrefix(null),
    WriteFiles((doc, ctx) => "feeds.opml")
);

//////////////////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////////////////

public async Task<IEnumerable<IDocument>> GetProjectGitHubData(IReadOnlyList<IDocument> inputs, IExecutionContext context)
{            
    string[] microsoftOwners = new []
    {
        "dotnet",
        "aspnet",
        "microsoft",
        "nuget",
        "mono",
        "azure"
    };

    GitHubClient github = new GitHubClient(new ProductHeaderValue("discoverdotnet"))
    {
        Credentials = new Credentials(context.String("GitHubToken"))
    };
    DateTimeOffset oneDayAgo = DateTimeOffset.Now.AddHours(-24);

    Wyam.Common.Tracing.Trace.Information($"Getting .NET Foundation readme");
    string foundationReadme;
	using (HttpClient httpClient = new HttpClient())
	{
        httpClient.DefaultRequestHeaders.Add("User-Agent", "Discoverdot.net build process");
		foundationReadme = await httpClient.GetStringAsync("https://raw.githubusercontent.com/dotnet/home/master/README.md");
	}

    // Even though it's much slower, we have to query the GitHub API sequentially or else we'll trigger the abuse detection mechanisms:
    // "Make requests for a single user or client ID serially. Do not make requests for a single user or client ID concurrently."
    // https://developer.github.com/v3/guides/best-practices-for-integrators/#dealing-with-abuse-rate-limits

    List<IDocument> outputs = new List<IDocument>();
    foreach(IDocument input in inputs)
    {
        IDocument output = input;

        // Extract the GitHub owner and name
        Uri source;
        if(Uri.TryCreate(input.String("Source"), UriKind.Absolute, out source)
            && source.Host.EndsWith("github.com", StringComparison.OrdinalIgnoreCase))
        {
            string owner = source.Segments[1].Trim('/');
            string name = source.Segments[2].Trim('/');

            int tries = 2;
            while(true)
            {
                // Connect to GitHub and get the repository
                try
                {
                    Wyam.Common.Tracing.Trace.Information($"Getting GitHub data for {owner}/{name}");
                    Repository repository = await github.Repository.Get(owner, name);

                    // Get the metadata
                    MetadataItems metadata = new MetadataItems
                    {
                        { "StargazersCount", repository.StargazersCount },
                        { "ForksCount", repository.ForksCount },
                        { "OpenIssuesCount", repository.OpenIssuesCount },
                        { "PushedAt", repository.PushedAt },
                        { "CreatedAt", repository.CreatedAt }
                    };
                    if(!input.ContainsKey("Title"))
                    {
                        metadata.Add("Title", repository.Name);
                    }
                    if(!input.ContainsKey("Description"))
                    {
                        metadata.Add("Description", repository.Description);
                    }
                    if(!input.ContainsKey("Website"))
                    {
                        metadata.Add("Website", repository.Homepage);
                    }
                    if(!input.ContainsKey("Microsoft") && microsoftOwners.Contains(owner, StringComparer.OrdinalIgnoreCase))
                    {
                        metadata.Add("Microsoft", true);
                    }
                    if(!input.ContainsKey("Foundation") && foundationReadme.IndexOf($"github.com/{owner}/{name}", StringComparison.OrdinalIgnoreCase) >= 0)
                    {
                        metadata.Add("Foundation", true);
                    }

                    // Get the readme
                    Wyam.Common.Tracing.Trace.Information($"Getting GitHub readme for {owner}/{name}");
                    try
                    {
                        string readme = await github.Repository.Content.GetReadmeHtml(owner, name);
                        if(!string.IsNullOrEmpty(readme))
                        {
                            metadata.Add("Readme", readme);
                        }
                    }
                    catch(Exception readmeEx)
                    {        
                        Wyam.Common.Tracing.Trace.Information($"Exception getting GitHub readme for {owner}/{name}: {readmeEx.Message}");                
                    }

                    // Return a document with GitHub metadata
                    output = context.GetDocument(input, metadata); 
                }
                catch(Exception ex)
                {
                    Wyam.Common.Tracing.Trace.Information($"Exception getting GitHub data for {owner}/{name}: {ex.Message}");
                    if(tries-- == 0)
                    {
                        throw;
                    }
                    continue;
                }        
                    
                break;                 
            }      

            // Report on our API rate limit
            MiscellaneousRateLimit rateLimit = await github.Miscellaneous.GetRateLimits();
            Wyam.Common.Tracing.Trace.Information($"GitHub rate limit: {rateLimit.Resources.Core.Remaining} remaining");
        }

        outputs.Add(output);
    }

    return outputs;
}

public class VersionData
{
    public string Version { get; }
    public string Downloads { get; }
    public DateTime LastUpdated { get; }

    public VersionData(AngleSharp.Dom.IElement element)
    {
		Version = element.Children[1].TextContent.Replace("(current)", string.Empty).Trim();
		Downloads = element.Children[2].TextContent.Trim();
		LastUpdated = DateTime.Parse(element.QuerySelector("*[data-datetime]").GetAttribute("data-datetime"));
    }
}

public class PackageData
{
    public string Id { get; set; }
    public string TotalDownloads { get; set; }
    public string PerDayDownloads { get; set; }
    public List<VersionData> Versions { get; set; } // In descending order

    public VersionData LatestVersion => Versions.FirstOrDefault();
}

public async Task<IEnumerable<IDocument>> GetProjectNuGetData(IReadOnlyList<IDocument> inputs, IExecutionContext context)
{
    AngleSharp.IConfiguration config = AngleSharp.Configuration.Default.WithDefaultLoader();
    
    List<IDocument> outputs = new List<IDocument>();
    foreach(IDocument input in inputs)
    {
        IDocument output = input;
        List<PackageData> packageData = new List<PackageData>();
        IReadOnlyList<string> packages = input.List<string>("NuGet", Array.Empty<string>());
        foreach(string package in packages.Where(x => !string.IsNullOrWhiteSpace(x)))
        {
            Wyam.Common.Tracing.Trace.Information($"Getting NuGet data for {package}");
            try
            {
                IBrowsingContext browsingContext = BrowsingContext.New(config);
                AngleSharp.Dom.IDocument document = await browsingContext.OpenAsync($"https://www.nuget.org/packages/{package}");
                if(document.StatusCode != System.Net.HttpStatusCode.OK)
                {
                    Wyam.Common.Tracing.Trace.Warning($"Bad status code for {package}: {document.StatusCode}");
                }
                else if(document == null)
                {
                    Wyam.Common.Tracing.Trace.Warning($"Could not get document for {package}");
                }
                else
                {
                    PackageData data = new PackageData
                    {
                        Id = package
                    };

                    // Get statistics
                    AngleSharp.Dom.IElement statistics = document
                        .QuerySelectorAll(".package-details-info h2")
                        .First(x => x.TextContent == "Statistics")
                        .NextElementSibling;
                    data.TotalDownloads = statistics.Children
                        .First(x => x.TextContent.Contains("total downloads"))
                        .TextContent.Trim().Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)[0];
                    data.PerDayDownloads = statistics.Children
                        .First(x => x.TextContent.Contains("per day"))
                        .TextContent.Trim().Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)[0];

                    // Get versions
                    data.Versions = document
                        .QuerySelectorAll("#version-history table tbody tr")
                        .Select(x => new VersionData(x))
                        .ToList();
                    
                    // Add the data
                    packageData.Add(data);
                }
            }
            catch(Exception ex)
            {
                Wyam.Common.Tracing.Trace.Warning($"Error getting NuGet data for {package}: {ex.Message}");
            }
        }

        if(packageData.Count > 0)
        {            
            // Return a new document with package data
            output = context.GetDocument(input, new MetadataItems
            {
                { "NuGetPackages", packageData }
            });
        }

        outputs.Add(output);
    }

    return outputs;
}

public class FeedItemData
{
    public string Title { get; }
    public string Link { get; }
    public string Description { get; }
    public DateTimeOffset Published { get; }
    public bool Recent { get; }
    public IDictionary<string, string> Links { get; }
    public string Author { get; }

    public FeedItemData(ISyndicationItem item, DateTimeOffset recent)
    {
        Title = item.Title;
        Link = item.Links.FirstOrDefault(x => x.RelationshipType == RssLinkTypes.Alternate)?.Uri.ToString() ?? item.Id;
        Published = item.Published != default(DateTimeOffset) ? item.Published : item.LastUpdated;
        Recent = Published > recent;
        Description = item.Description;
        Links = item.Links
            .Where(x => !string.IsNullOrEmpty(x.MediaType))
            .GroupBy(x => x.MediaType)
            .Select(x => x.First())
            .ToDictionary(x => x.MediaType, x => x.Uri.ToString());

        ISyndicationPerson person = item.Contributors.FirstOrDefault(x => x.RelationshipType == "author");
        if(person != null)
        {
            Author = person.Name ?? person.Email;
        }

        AtomEntry atom = item as AtomEntry;
        if(atom != null && !string.IsNullOrEmpty(atom.Summary))
        {
            Description = atom.Summary;            
        }
    }
}

public async Task<IEnumerable<IDocument>> GetFeedData(IReadOnlyList<IDocument> inputs, IExecutionContext context)
{
    DateTimeOffset recent = new DateTimeOffset(DateTime.Today.AddHours(context.Bool("Preview") ? -168 : -48));
    return await Task.WhenAll(
        inputs.Select(async input =>
        {
            string feed = input.String("Feed");
            if(!string.IsNullOrEmpty(feed))
            {
                try
                {
                    // Download the feed
                    Wyam.Common.Tracing.Trace.Information($"Getting feed for {feed}");
                    string website = null;
                    string title = null;
                    string author = null;
                    string description = null;
                    string image = null;
                    List<ISyndicationItem> items = new List<ISyndicationItem>();
                    using (HttpClient httpClient = new HttpClient())
                    {
                        httpClient.DefaultRequestHeaders.Add("User-Agent", "Discoverdot.net build process");

                        using (Stream stream = await httpClient.GetStreamAsync(feed))
                        {
                            using (StreamReader streamReader = new XmlStreamReader(stream))
                            {
                                using(XmlReader xmlReader = XmlReader.Create(streamReader, new XmlReaderSettings { Async = true, DtdProcessing = DtdProcessing.Ignore }))
                                {
                                    xmlReader.MoveToContent();
                                    bool atom = xmlReader.Name == "feed";
                                    Wyam.Common.Tracing.Trace.Information($"Reading {feed} as " + (atom ? "Atom" : "RSS"));
                                    XmlFeedReader feedReader = atom
                                        ? (XmlFeedReader)new AtomFeedReader(xmlReader, new DiscoverAtomParser())
                                        : new RssFeedReader(xmlReader);                            
                                    while(await feedReader.Read())
                                    {
                                        try
                                        {
                                            switch(feedReader.ElementType)
                                            {
                                                case SyndicationElementType.Person:
                                                    ISyndicationPerson person = await feedReader.ReadPerson();
                                                    if(person.RelationshipType == "author")
                                                    {
                                                        author = person.Name ?? person.Email;
                                                    }
                                                    break;

                                                case SyndicationElementType.Image:
                                                    ISyndicationImage img = await feedReader.ReadImage();
                                                    image = img.Url.ToString();
                                                    break;

                                                case SyndicationElementType.Link:
                                                    ISyndicationLink link = await feedReader.ReadLink();
                                                    website = link.Uri.ToString();
                                                    break;	
                                                    
                                                case SyndicationElementType.Item:
                                                    ISyndicationItem item = await feedReader.ReadItem();
                                                    items.Add(item);
                                                    break;                                    
                                                
                                                case SyndicationElementType.None:
                                                    break;
                                                    
                                                default:
                                                    ISyndicationContent content = await feedReader.ReadContent();
                                                    if(string.Equals(content.Name, "title", StringComparison.OrdinalIgnoreCase))
                                                    {
                                                        title = content.Value;
                                                    }
                                                    else if(string.Equals(content.Name, "description", StringComparison.OrdinalIgnoreCase)
                                                        || string.Equals(content.Name, "subtitle", StringComparison.OrdinalIgnoreCase))
                                                    {
                                                        description = content.Value;
                                                    }
                                                    break;
                                            }
                                        }
                                        catch(Exception ex)
                                        {
                                            Wyam.Common.Tracing.Trace.Warning($"Exception while processing {feedReader.ElementType} in {feed}: {ex.Message}");
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // Get a new document with feed metadata
                    MetadataItems metadata = new MetadataItems();
                    if(items.Count > 0)
                    {
                        FeedItemData[] feedItems = items
                            .Select(x => new FeedItemData(x, recent))
                            .OrderByDescending(x => x.Published)
                            .Take(50)  // Only take the 50 most recent items
                            .ToArray();
                        metadata.Add("FeedItems", feedItems);
                        metadata.Add("LastPublished", feedItems.First().Published);
                        metadata.Add("NewestFeedItem", feedItems[0]);
                    };
                    if(!input.ContainsKey("Website") && !string.IsNullOrEmpty(website))
                    {
                        metadata.Add("Website", website);
                    }
                    if(!input.ContainsKey("Title"))
                    {
                        if(!string.IsNullOrEmpty(title))
                        {
                            metadata.Add("Title", title);
                        }
                        else
                        {
                            var generatedTitle = GenerateTitleFromFeedName(feed);
                            metadata.Add("Title", generatedTitle);
                        }
                    }
                    if(!input.ContainsKey("Author") && !string.IsNullOrEmpty(author))
                    {
                        metadata.Add("Author", author);
                    }
                    if(!input.ContainsKey("Description") && !string.IsNullOrEmpty(description))
                    {
                        metadata.Add("Description", description);
                    }
                    if(!input.ContainsKey("Image") && !string.IsNullOrEmpty(image))
                    {
                        metadata.Add("Image", image);
                    }
                    return context.GetDocument(input, metadata);
                }
                catch(Exception ex) 
                {
                    Wyam.Common.Tracing.Trace.Warning($"Error getting feed for {feed}: {ex.Message}");
                }
            }

            return null;
        }));
}

public string GenerateTitleFromFeedName(string feed)
{
    var slashes = "//";
    
    int from = feed.IndexOf(slashes) + slashes.Length;
    int to = feed.IndexOf("/", from);

    var title = feed.Substring(from, to - from);

    return title;
}

// See https://github.com/dotnet/SyndicationFeedReaderWriter/issues/31
public class DiscoverAtomParser : AtomParser
{
	public override IAtomEntry CreateEntry(ISyndicationContent content)
	{
		// Remove author and contributor entries if they don't contain an email or name
		ICollection<ISyndicationContent> children = (ICollection<ISyndicationContent>)content.Fields;
		ISyndicationContent author = children.FirstOrDefault(x => x.Name == AtomContributorTypes.Author);
		if(author != null
			&& author.Fields.FirstOrDefault(x => x.Name == "name")?.Value == null
			&& author.Fields.FirstOrDefault(x => x.Name == "email")?.Value == null)
		{
			children.Remove(author);
		}
		ISyndicationContent contributor = children.FirstOrDefault(x => x.Name == AtomContributorTypes.Contributor);
		if (contributor != null
			&& contributor.Fields.FirstOrDefault(x => x.Name == "name")?.Value == null
			&& contributor.Fields.FirstOrDefault(x => x.Name == "email")?.Value == null)
		{
			children.Remove(contributor);
		}
		return base.CreateEntry(content);
	}
}

public class XmlStreamReader : StreamReader
{
	public XmlStreamReader(Stream stream) : base(stream)
	{
	}

	public override int Peek()
	{
		int ch = 0;
		while (ch != -1)
		{
			ch = base.Peek();
			if (XmlConvert.IsXmlChar((char)ch))
			{
				return ch;
			}
			base.Read();
		}
		return ch;
	}

	public override int Read()
	{
		int ch = 0;
		while (ch != -1)
		{
			ch = base.Read();
			if (XmlConvert.IsXmlChar((char)ch))
			{
				return ch;
			}
		}
		return ch;
	}

	public override int Read(char[] buffer, int index, int count)
	{
		int i;
		for(i = index ; i < count ; i++)
		{
			int c = Read();
			if(c == -1)
			{
				break;
			}
			buffer[i] = (char)c;
		}
		return i - index;
	}
}

public class MeetupGroup
{
	public string Name { get; set; }
	public string Link { get; set; }
    public string Localized_Location { get; set; }
    public string Localized_Country_Name { get; set; }
    public string Lat { get; set; }
    public string Lon { get; set; }
	public NextEvent Next_Event { get; set; }
    public Photo Key_Photo { get; set; }

	public class NextEvent
	{
        public string Id { get; set; }
		public string Name { get; set; }
		public long Time { get; set; }
		public long Utc_Offset { get; set; }
		public DateTimeOffset Date => DateTimeOffset.FromUnixTimeMilliseconds(Time);
		public DateTimeOffset LocalDate => Date.AddMilliseconds(Utc_Offset);

        public MetadataItems GetMetadata(MeetupGroup group)
        {
            return new MetadataItems
            {
                { "Website", $"{group.Link}events/{Id}" },
                { "Title", Name },
                { "Location", group.Localized_Location },
                { "Country", group.Localized_Country_Name },
                { "Lat", group.Lat },
                { "Lon", group.Lon },
                { "Date", LocalDate.ToString("yyyy/MM/dd") },
                { "Time", LocalDate.ToString("HH:mm") }
            };
        }
	}

    public class Photo
    {
        public string Photo_Link { get; set; }
    }
    
    public MetadataItems GetMetadata()
    {
        MetadataItems metadata = new MetadataItems
        {
            { "Title", Name },
            { "Website", Link },
            { "Location", Localized_Location },
            { "Country", Localized_Country_Name },
            { "Lat", Lat },
            { "Lon", Lon }
        };
        string image = Key_Photo?.Photo_Link;
        if(!string.IsNullOrEmpty(image))
        {
            metadata.Add("Image", image);
        }
        if(Next_Event != null)
        {
            metadata.Add("NextEvent", Next_Event.GetMetadata(this));
            metadata.Add("NextEventWebsite", $"{Link}events/{Next_Event.Id}");
            metadata.Add("NextEventTitle", Next_Event.Name);
            metadata.Add("NextEventDate", Next_Event.LocalDate.ToString("yyyy/MM/dd"));
            metadata.Add("NextEventTime", Next_Event.LocalDate.ToString("HH:mm"));
        }
        return metadata;
    }
}

public async Task<IEnumerable<IDocument>> GetMeetupData(IReadOnlyList<IDocument> inputs, IExecutionContext context)
{
    // Get groups with a topic of ".NET" (topic_id = 827)
    string meetupToken = context.String("MeetupToken");
    JsonSerializer serializer = new JsonSerializer();
	List<MeetupGroup> groups = new List<MeetupGroup>();
	using (HttpClient httpClient = new HttpClient())
	{
        httpClient.DefaultRequestHeaders.Add("User-Agent", "Discoverdot.net build process");
		int offset = 0;
		while (true)
		{
            Wyam.Common.Tracing.Trace.Information($"Getting group data for offset {offset}");
			using (Stream stream = await httpClient.GetStreamAsync(
                $"https://api.meetup.com/find/groups?topic_id=827&only=name,link,localized_location,localized_country_name,lat,lon,key_photo,next_event&radius=global&page=200&offset={offset}&key={meetupToken}"))
			{
				using (StreamReader streamReader = new StreamReader(stream))
				{
					using (JsonTextReader jsonReader = new JsonTextReader(streamReader))
					{
						IList<MeetupGroup> results = serializer.Deserialize<IList<MeetupGroup>>(jsonReader);
						groups.AddRange(results);
						if(results.Count == 0 || context.Bool("Preview"))
						{
							break;
						}
						offset++;
					}
				}
			}
		}
	}
    IList<IDocument> outputs = groups.Select(x => context.GetDocument(x.GetMetadata())).ToList();

    // Process input documents    
	using (HttpClient httpClient = new HttpClient())
	{
        httpClient.DefaultRequestHeaders.Add("User-Agent", "Discoverdot.net build process");
        foreach(IDocument input in inputs)
        {
            string meetup = input.String("Meetup");
            if(!string.IsNullOrEmpty(meetup))
            {            
                // Query API for Meetup groups that aren't already part of the .NET topic set
                Wyam.Common.Tracing.Trace.Information($"Getting group data for group {meetup}");
                using (Stream stream = await httpClient.GetStreamAsync(
                    $"https://api.meetup.com/{meetup}?only=name,link,localized_location,localized_country_name,lat,lon,key_photo,next_event&key={meetupToken}"))
                {
                    using (StreamReader streamReader = new StreamReader(stream))
                    {
                        using (JsonTextReader jsonReader = new JsonTextReader(streamReader))
                        {
                            MeetupGroup group = serializer.Deserialize<MeetupGroup>(jsonReader);
                            outputs.Add(context.GetDocument(group.GetMetadata()));
                        }
                    }
                }
            }
            else
            {
                // Not on Meetup, just add this group directly
                outputs.Add(input);
            }
        }
    }

    // TODO: Add Meetup events to the Meetup group documents for the events pipeline to use

    return outputs.OrderBy(x => x.String("Title"));
}